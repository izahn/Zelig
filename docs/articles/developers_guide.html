<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Developer’s Guide • Zelig</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/paper/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">Zelig Project</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/quickstart.html">Quickstart</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Vignettes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/index.html#section-zelig-overview">Zelig Overview</a>
    </li>
    <li>
      <a href="../articles/index.html#section-core-zelig-model-details">Zelig Model Details</a>
    </li>
    <li>
      <a href="../articles/index.html#section-other">Other</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Function Reference
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../reference/index.html#section-main-zelig-workflow">Workflow</a>
    </li>
    <li>
      <a href="../reference/index.html#section-estimation-methods">Estimation Methods</a>
    </li>
    <li>
      <a href="../reference/index.html#section-exterior-interaction-functions">Interacting Outside of Zelig</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    About
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/about.html">Contact/Development Team/Citation</a>
    </li>
    <li>
      <a href="../articles/roadmap.html">Development Roadmap</a>
    </li>
    <li>
      <a href="https://iqss.github.io/rpackagemetrics/">Zelig Adoption Metrics</a>
    </li>
    <li>
      <a href="https://raw.githubusercontent.com/IQSS/Zelig/master/.iqss_reportcard.yml">Statistical Software Devepment Reportcard</a>
    </li>
  </ul>
</li>
<li>
  <a href="https://medium.com/zelig-dev/archive">
    <span class="fa fa-medium"></span>
     
    Dev-Blog
  </a>
</li>
<li>
  <a href="https://twitter.com/zeligproject">
    <span class="fa fa-twitter fa-2x"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/IQSS/Zelig">
    <span class="fa fa-github fa-2x"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Developer’s Guide</h1>
            
            <h4 class="date">2017-11-03</h4>
          </div>

    
    
<div class="contents">
<p><em>Built using Zelig version 5.1.4</em></p>
<p>This is a guide for contributing to the Zelig Project by adding new statistical models into Zelig. Before getting started, familiarize yourself with R’s Reference Classes (RC), as Zelig5 makes extensive use of RCs to allow for the straightforward addition of new models. Useful resources include Hadley Wickham’s <a href="http://adv-r.had.co.nz/R5.html">chapter on Reference Classes</a>, and R’s <a href="https://stat.ethz.ch/R-manual/R-devel/library/methods/html/refClass.html">ReferenceClasses documentation</a>. Be sure to read <a href="http://gking.harvard.edu/files/making.pdf">King, Tomz, and Wittenberg (2000)</a> for the underlying algorithm that is deployed in Zelig. Finally, explore <a href="http://zeligproject.org/">zeligproject.org</a> to learn more about Zelig and our plans for the future.</p>
<p>In the abstract, Zelig is a tool for estimating and visualizing easily interpretable quantities of interest for statistical models in R. To do so, Zelig leverages R’s open-source philosophy and builds on existing statistical model implementations such as those found in <strong>stats</strong> and <strong>VGAM</strong>. Consider the following R code for a typical Zelig 5 workflow:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(turnout)
z5 &lt;-<span class="st"> </span>zlogit<span class="op">$</span><span class="kw">new</span>()
z5<span class="op">$</span><span class="kw"><a href="../reference/zelig.html">zelig</a></span>(vote <span class="op">~</span><span class="st"> </span>age, <span class="dt">data =</span> turnout)
z5<span class="op">$</span><span class="kw"><a href="../reference/setx.html">setx</a></span>()
z5<span class="op">$</span><span class="kw"><a href="../reference/sim.html">sim</a></span>()
z5<span class="op">$</span><span class="kw">graph</span>()</code></pre></div>
<p>First, we load the data. Then, the next five lines of code are nearly identical for any model in Zelig. The one exception is the first, in which we assign a new model object to z5. <code>zlogit</code> is the RC, and the <code>$</code> component selector means we are calling a method inside that RC. Each RC is its own environment, and a method is a function that is internal to that environment. Think of the RC as a home, and the method as a room in the home. To enter a room, you must first be inside the home.</p>
<p><code>z5</code> is assigned the RC <code>zlogit</code>. <code>new()</code>, <code><a href="../reference/zelig.html">zelig()</a></code>, <code><a href="../reference/setx.html">setx()</a></code>, <code><a href="../reference/sim.html">sim()</a></code>, and <code>graph()</code> are all methods inside <code>zlogit</code> and, thus, inside <code>z5</code>. Anything entered between the parenthesis are arguments passed to the method. <code><a href="../reference/zelig.html">zelig()</a></code> is the method that calls the underlying estimation function, which for logistic regression is <code>glm()</code>. The arguments we pass to <code><a href="../reference/zelig.html">zelig()</a></code> are, minimally, the arguments we would pass to <code>glm()</code> if we were to call it directly. <code><a href="../reference/zelig.html">zelig()</a></code> also accepts some arguments that may not be accepted by the existing function, such as <code>by</code>.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> <code><a href="../reference/setx.html">setx()</a></code> is a function that sets the predictor values at which we want to simulate. In most implementations, <code><a href="../reference/setx.html">setx()</a></code> is independent of the model and contributors need not be concerned with it. <code><a href="../reference/sim.html">sim()</a></code> is the method that simulates draws from the data. For contributors, this is where the model’s link function, or the systematic component, is called. It is also where the relevant quantities of interest are specified. <code>graph()</code> visualizes the output of <code><a href="../reference/sim.html">sim()</a></code>, and while your model may have visualizations that you’d like to add, these are optional, as <code>graph()</code> has base visualizations that always work on the simulated estimates.</p>
<p>In this guide, we are going to walk through an example with the logit model, as implemented by <code>glm()</code> in the <a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/00Index.html">stats</a> library to Zelig.</p>
<div id="getting-started" class="section level2">
<h2 class="hasAnchor">
<a href="#getting-started" class="anchor"></a>Getting Started</h2>
<p>First, let’s download Zelig and load the project in RStudio. This will make it easier to see how the package works in its entirety.</p>
<p>If you haven’t already, download and install <a href="http://www.rstudio.com/">RStudio</a>. Then go to <a href="https://github.com/IQSS/Zelig">GitHub and download Zelig</a>.</p>
<p>In RStudio, click the Files tab and navigate to the folder <em>Zelig-master</em>, which you just downloaded. Select and load <em>Zelig.Rproj</em>. In RStudio, then click the Build tab, and Build &amp; Reload. This rebuilds the package and loads it into R.</p>
<p>Next, from RStudio open the following files, found in <em>Zelig-master/R</em>:</p>
<ul>
<li><em>model-zelig.R</em></li>
<li><em>model-glm.R</em></li>
<li><em>model-binchoice.R</em></li>
<li><em>model-logit.R</em></li>
</ul>
<p>If you’re new to RStudio or would like to better understand what’s going on, add a print statement and rebuild the package. For example, inside <em>model-zelig.R</em>, find <code>zelig = function</code>. This is where the <code><a href="../reference/zelig.html">zelig()</a></code> method is declared. Inside the <code><a href="../reference/zelig.html">zelig()</a></code> method, add a line, <code>cat('Zelig')</code>. Save, and then click Build &amp; Reload in RStudio. After entering the following code in the R console:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(turnout)
z5 &lt;-<span class="st"> </span>zlogit<span class="op">$</span><span class="kw">new</span>()
z5<span class="op">$</span><span class="kw"><a href="../reference/zelig.html">zelig</a></span>(vote ∼ age, <span class="dt">data =</span> turnout)</code></pre></div>
<p>you should see <code>Zelig</code> printed in the console.</p>
</div>
<div id="reference-classes-and-inheritance" class="section level2">
<h2 class="hasAnchor">
<a href="#reference-classes-and-inheritance" class="anchor"></a>Reference Classes and Inheritance</h2>
<p>RCs have three important properties: (1) they contain fields, (2) they contain methods, and (3) they can inherit fields and methods from other RCs. See the <a href="available_models_overview.html">Inheritance Tree</a>. Notice that <em>Zelig-logit</em> inherits from <em>Zelig-binchoice</em>, <em>Zelig-glm</em>, and <em>Zelig</em>. Each of these nodes in the Inheritance Tree corresponds to a file that we just opened in RStudio.</p>
<p>To contribute a new package, you’ll minimally inherit from Zelig. But, you may extend the inheritance or inherit additional classes, depending on the way your model relates to others. Inheretance should follow a logical structure. Consider logit’s inheritance. <em>Zelig-glm</em> inherits from <em>Zelig</em>, and the <code>glm()</code> function can be used to estimate the following models: <code>gamma</code>, <code>normal</code>, <code>poisson</code>, <code>probit</code>, and <code>logit</code>. Look at these <code>poisson</code>, <code>logit</code>, and <code>probit</code> estimations:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit.poisson &lt;-<span class="st"> </span><span class="kw">glm</span>(vote ∼ age, <span class="dt">data=</span>turnout, <span class="dt">family =</span> <span class="kw">poisson</span>())
fit.logit &lt;-<span class="st"> </span><span class="kw">glm</span>(vote ∼ age, <span class="dt">data=</span>turnout, <span class="dt">family=</span><span class="kw">binomial</span>(<span class="st">"logit"</span>))
fit.probit &lt;-<span class="st"> </span><span class="kw">glm</span>(vote ∼ age, <span class="dt">data=</span>turnout, <span class="dt">family=</span><span class="kw">binomial</span>(<span class="st">"probit"</span>))</code></pre></div>
<p>The <code>family</code> argument is what distinguishes these three estimations, but notice that, while <code>poisson</code>’s <code>family</code> is <code>poisson()</code>, <code>logit</code>’s and <code>probit</code>’s <code>family</code> are both <code>binomial()</code>. So, while poisson may inherit from <em>Zelig-glm</em> and stop there, <code>logit</code> and <code>probit</code> go one step further and inherit from an intermediary class called <em>Zelig-binchoice</em>, which inherits from <em>Zelig-glm</em>.</p>
</div>
<div id="zelig-methods" class="section level2">
<h2 class="hasAnchor">
<a href="#zelig-methods" class="anchor"></a>Zelig Methods</h2>
<p>A commonly used implementation of the logistic regression is the <code>glm()</code> function in stats. Load Zelig’s <code>turnout</code> data with <code>data(turnout)</code>, and estimate <code>vote ~ age</code> using <code>glm()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit &lt;-<span class="st"> </span><span class="kw">glm</span>(vote ∼ age, <span class="dt">data=</span>turnout, <span class="dt">family=</span><span class="kw">binomial</span>(<span class="st">"logit"</span>))</code></pre></div>
<p>The Zelig counterpart would be:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z5 &lt;-<span class="st"> </span>zlogit<span class="op">$</span><span class="kw">new</span>()
z5<span class="op">$</span><span class="kw"><a href="../reference/zelig.html">zelig</a></span>(vote ∼ age, <span class="dt">data =</span> turnout)</code></pre></div>
<p>You could also use the Zelig 4 wrapper:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z5 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/zelig.html">zelig</a></span>(vote ∼ age, <span class="dt">data =</span> turnout, <span class="dt">model =</span> <span class="st">"logit"</span>)</code></pre></div>
</div>
<div id="new" class="section level2">
<h2 class="hasAnchor">
<a href="#new" class="anchor"></a><code>new()</code>
</h2>
<p>We initialize the Zelig object when users enter <code>z5 &lt;- zlogit\$new()</code> in the R console. This is when all the information necessary to wrap the logit model using <code>glm()</code> is initialized, and is accomplished using the <code>initialize()</code> method. To understand how the Zelig object is initialized, let’s first explore the inheritance. When we write a RC, we can specify another RC whose fields and methods will be inherited by our RC. Recall logit’s inheritance:</p>
<p><span class="math display">\[\tt{Zelig} \rightarrow \tt{Zelig-glm} \rightarrow \tt{Zelig-binchoice} \rightarrow \tt{Zelig-logit} \]</span></p>
<p>Look at the first lines of code in each of the files opened in RStudio, and you’ll see <code>setRefClass()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">zlogit &lt;-<span class="st"> </span><span class="kw">setRefClass</span>(<span class="st">"Zelig-logit"</span>,
                      <span class="dt">contains =</span> <span class="st">"Zelig-binchoice"</span>)</code></pre></div>
<p>The chain of inheritance is passed using the contains argument. Starting at the end of the inheritance tree, the RC <em>Zelig-logit</em> contains, or inherits from, the RC <em>Zelig-binchoice</em>, which inherits from the RC <em>Zelig-glm</em>,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">zbinchoice &lt;-<span class="st"> </span><span class="kw">setRefClass</span>(<span class="st">"Zelig-binchoice"</span>,
                          <span class="dt">contains =</span> <span class="st">"Zelig-glm"</span>)</code></pre></div>
<p>which inherits from the RC <em>Zelig</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">zglm &lt;-<span class="st"> </span><span class="kw">setRefClass</span>(<span class="st">"Zelig-glm"</span>,
                    <span class="dt">contains =</span> <span class="st">"Zelig"</span>,
                    <span class="dt">fields =</span> <span class="kw">list</span>(<span class="dt">family =</span> <span class="st">"character"</span>,
                                  <span class="dt">link =</span> <span class="st">"character"</span>,
                                  <span class="dt">linkinv =</span> <span class="st">"function"</span>))</code></pre></div>
<p>In <em>Zelig</em>, we establish our most basic fields and methods, and get more specific as we move down the inheritance.</p>
<p>When <code>zlogit$new()</code> is called, we actually call <code>initialize()</code> first at the end of the inheritance, inside <em>Zelig-logit</em>. Look inside <em>model-logit.R</em> at <code>initialize()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">zlogit<span class="op">$</span><span class="kw">methods</span>(<span class="dt">initialize =</span> <span class="cf">function</span>() {
    <span class="kw">callSuper</span>()
    .self<span class="op">$</span>name &lt;-<span class="st"> "logit"</span>
    .self<span class="op">$</span>link &lt;-<span class="st"> "logit"</span>
    .self<span class="op">$</span>description =<span class="st"> "Logistic Regression for Dichotomous Dependent Variables"</span>
    .self<span class="op">$</span>packageauthors &lt;-<span class="st"> "R Core Team"</span>
    .self<span class="op">$</span>wrapper &lt;-<span class="st"> "logit"</span>
})</code></pre></div>
<p>The first line is <code>callSuper()</code>. <code>callSuper()</code> is a method that is common to all RCs, and useful particularly for inheritance. What it does it simple: it calls the same function in the parent object, or the object that the present object inherits from. So, since <em>Zelig-logit</em> inherits from <em>Zelig-binchoice</em>, <code>callSuper()</code> in <code>initialize()</code> calls <code>initialize()</code> inside <em>Zelig-binchoice</em>, where the first function is also <code>callSuper()</code>, and so <code>initialize()</code> is called in <em>Zelig-glm</em>, where the first function is also <code>callSuper()</code>, and so <code>initialize()</code> is called in <em>Zelig</em>. <em>Zelig</em> is at the top of the tree, and so now that we have climbed up the inheritance tree, we next climb down the tree, executing all functions inside <code>initialize()</code> and after <code>callSuper()</code>, first in <em>Zelig</em>, then <em>Zelig-glm</em>, then <em>Zelig-binchoice</em>, and lastly <em>Zelig-logit</em>.</p>
<p>To summarize: upon executing <code>z5 &lt;- zlogit$new()</code>, we <code>callSuper()</code> inside <code>initialize()</code>, beginning at the end of the inheritance (<em>Zelig-logit</em>) and climbing to the top (<em>Zelig</em>). Then, for each RC, everything below <code>callSuper()</code> inside <code>initialize()</code> is executed, beginning at the top of the inheritance (<em>Zelig</em>) and climbing down (<em>Zelig-logit</em>), assigning the RC’s fields as we descend. For example, in <em>Zelig</em> <code>.self$authors &lt;- "Kosuke Imai, Gary King, and Olivia Lau"</code>, and in <em>Zelig-logit</em>, <code>.self$link &lt;- "logit"</code>. Doing so initializes our <em>Zelig</em> object, which now waits for <code><a href="../reference/zelig.html">zelig()</a></code> to be called.</p>
</div>
<div id="zelig" class="section level2">
<h2 class="hasAnchor">
<a href="#zelig" class="anchor"></a><code><a href="../reference/zelig.html">zelig()</a></code>
</h2>
<p><code><a href="../reference/zelig.html">zelig()</a></code> will help to make sense of why <code>initialize()</code> specifies the fields that it does. Let’s look at <code><a href="../reference/zelig.html">zelig()</a></code> inside <em><a href="https://github.com/IQSS/Zelig/blob/master/R/model-glm.R">model-glm.R</a></em>, the last RC in the inheritance to modify <code><a href="../reference/zelig.html">zelig()</a></code>. Recall that in <code>initialize()</code>, we started at the bottom of the inheritance, and because the first line is always <code>callSuper()</code>, we climbed to the top before executing any other function in <code>initialize()</code>. Well, here we don’t <code>callSuper()</code> until later, meaning that the code above <code>callSuper()</code> is execute and then we <code>callSuper()</code> and climb to the parent object. As we descend the inheritance, the code below <code>callSuper()</code> is executed. Let’s have a look at the first lines of code in <code><a href="../reference/zelig.html">zelig()</a></code> in <em>model-glm.R</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">.self<span class="op">$</span>zelig.call &lt;-<span class="st"> </span><span class="kw">match.call</span>(<span class="dt">expand.dots =</span> <span class="ot">TRUE</span>)
.self<span class="op">$</span>model.call &lt;-<span class="st"> </span>.self<span class="op">$</span>zelig.call</code></pre></div>
<p>The first command stores the user’s initial zelig() call as it is written by the user. In our example, the field <strong>zelig.call</strong> would now be <code>z5$zelig(formula = vote ~ age, data = turnout)</code>. We now have the user’s call saved as zelig.call. You can see this by entering <code>z5$zelig.call</code> in the R console. Specifically, <strong>zelig.call</strong> is a field, and we can reach into z5 and pull out the field using the $ operator.</p>
<p>But this is not the call we use to estimate our model, because <code><a href="../reference/zelig.html">zelig()</a></code> is wrapping another function, <code>glm()</code>. To distinguish between the user’s zelig() call and the Zelig object’s glm() call, we copy <strong>zelig.call</strong> to a new field, <strong>model.call</strong>. <strong>model.call</strong> is the field that will be made to appear exactly as if we were to call glm() directly. Thus, if you ever use Zelig and want to know how you would estimate the same model using the package that Zelig wraps, you’ll want to look at the <strong>model.call</strong> field.</p>
<p>Keep in mind that what we are doing is transforming the initial two user commands into an equivalent form of the glm() call, <code>fit &lt;- glm(vote ~ age, data = turnout, family = binomial(logit))</code>. We are almost there, but still missing the <strong>family</strong> argument, an essential argument of glm() that must be of class family. This is accomplished with:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">.self<span class="op">$</span>model.call<span class="op">$</span>family &lt;-<span class="st"> </span><span class="kw">call</span>(.self<span class="op">$</span>family, .self<span class="op">$</span>link)</code></pre></div>
<p><strong>model.call</strong> does not have something called “family” prior to this line of code, so it is created and assigned <code>call(.self$family, .self$link)</code>, which is an object of class family. A little confusing, but consider the following example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myfam &lt;-<span class="st"> </span><span class="kw">binomial</span>(<span class="st">"logit"</span>)</code></pre></div>
<p><code>myfam</code> is an object of class family, as returned by <code>binomial("logit")</code>. For the glm() family argument, <code>binomial</code> tells us the type of outcome, and it is stored in the field <strong>family</strong>. “logit” is the name of the link function, and it is stored in <strong>link</strong>. Where did <code>.self$family</code> and <code>.self$link</code> come from? Recall the inheritance of initialize(). <strong>family</strong> is written to our Zelig object in <em>Zelig-binchoice</em>, and <strong>link</strong> is written to our Zelig object in <em>Zelig-logit</em>. So, <strong>model.call</strong> is now:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z5<span class="op">$</span><span class="kw"><a href="../reference/zelig.html">zelig</a></span>(<span class="dt">formula =</span> vote ∼ age, <span class="dt">data =</span> turnout, <span class="dt">family =</span> <span class="kw">binomial</span>(<span class="st">"logit"</span>))</code></pre></div>
<p>If we want to specify a different link function, e.g., probit, then all we would have to change is <code>.self$link &lt;- logit</code> to <code>.self$link &lt;- probit</code>. In fact, in Zelig’s probit model, <em>this is the only functional difference</em>. A couple other things are changed for descriptive purposes, such as the name to “probit”, but functionally, the difference is the <strong>link</strong> field. And, indeed, in a call to glm(), logit and probit appear identical with the exception of the binomial argument, which is either “logit” or “probit”.</p>
<p>Lastly, we <code>callSuper()</code>. Recall that this is a method that is common to all RCs; it calls the method of the same name in the object that this object inherits from. So, after assigning <strong>zelig.call</strong> and <strong>model.call</strong>, we call <code><a href="../reference/zelig.html">zelig()</a></code> in <em>Zelig</em> to actually compute the estimation.</p>
<p>Next, let’s look at the <code><a href="../reference/zelig.html">zelig()</a></code> method inside <em>Zelig</em>, seen in the <em>model-zelig.R</em> script. When contributing to Zelig, <em>model-zelig.R</em> should never be altered.</p>
<p>This method is very dense, and includes code for working with multiple datasets (e.g., those from Amelia) and the <strong>by</strong> argument, among other things. Let’s focus on Zelig’s logit model–the remainder of this section is only concerned with code in <code><a href="../reference/zelig.html">zelig()</a></code> explicitly related to estimating a single logit model from a single dataset. Specifically, look at:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">.self<span class="op">$</span>model.call[[<span class="dv">1</span>]] &lt;-<span class="st"> </span>.self<span class="op">$</span>fn</code></pre></div>
<p><code>.self$model.call</code> is a <code>call</code>, and the element indexed by [[1]] is literally the name of the function to be called. For example, <code>call(sum, c(1,1,3))</code> would return an object of type <code>call</code> that looks exactly like the string <code>sum(c(1,1,3))</code>, but contains elements that can be used to manipulate pieces of the string. Consider the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">t &lt;-<span class="st"> </span><span class="kw">call</span>(<span class="st">"sum"</span>, <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>))
<span class="kw">eval</span>(t)
t[[<span class="dv">1</span>]] &lt;-<span class="st"> </span><span class="kw">quote</span>(prod)
<span class="kw">eval</span>(t)</code></pre></div>
<p>The first <code>eval(t)</code> returns 5, the sum of the elements <code>(1,1,3)</code>. The second <code>eval(t)</code> returns 3, the product of the elements <code>(1,1,3)</code>. In <code><a href="../reference/zelig.html">zelig()</a></code>, the element of <strong>model.call</strong> we are manipulating is at [[1]]<code>, and it is the function to be called. Or, more precisely, it is whatever precedes the first open parenthesis. So, prior to assigning</code>.self<span class="math inline">\(fn` to `.self\)</span>model.call[[1]]<code>, the function to be called is</code>z5$zelig`, and <strong>model.call</strong> looks like:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z5<span class="op">$</span><span class="kw"><a href="../reference/zelig.html">zelig</a></span>(<span class="dt">formula =</span> vote ∼ age, <span class="dt">data =</span> turnout, <span class="dt">family =</span> <span class="kw">binomial</span>(<span class="st">"logit"</span>))</code></pre></div>
<p>After assigning <code>.self$fn</code> to <code>model.call[[1]]</code>, model.call looks like:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stats<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/stats/topics/glm">glm</a></span>(<span class="dt">formula =</span> vote ∼ age, <span class="dt">data =</span> turnout, <span class="dt">family =</span> <span class="kw">binomial</span>(<span class="st">"logit"</span>))</code></pre></div>
<p>The final line of code that we are concerned with is the final line in <code><a href="../reference/zelig.html">zelig()</a></code>, where <strong>model.call</strong> is evaluated:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">do</span>(<span class="dt">z.out =</span> <span class="kw">eval</span>(<span class="kw">fn2</span>(.self<span class="op">$</span>model.call, <span class="kw">quote</span>(.))))</code></pre></div>
<p>Ignore <code>do()</code> and <code>fn2()</code>, these are functions that help us handle multiple datasets, and are part of Zelig’s added value that comes free. All we are doing here is evaluating <strong>model.call</strong>, which, as is seen above, is now identical to the <code>glm()</code> call. Thus, we have wrapped <code>glm()</code> and estimated a logit model in the Zelig framework.</p>
</div>
<div id="sim" class="section level2">
<h2 class="hasAnchor">
<a href="#sim" class="anchor"></a><code><a href="../reference/sim.html">sim()</a></code>
</h2>
<p><a href="http://gking.harvard.edu/files/making.pdf">King, Tomz, and Wittenberg (2000)</a> present a general framework for simulating easily interpretable quantities of interest. We first set our predictor values at which we want to simulate, and then we simulate the quantities of interest, e.g., expected values, predicted values, and first differences. There are two simple Zelig commands to do this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z5<span class="op">$</span><span class="kw"><a href="../reference/setx.html">setx</a></span>()
z5<span class="op">$</span><span class="kw"><a href="../reference/sim.html">sim</a></span>()</code></pre></div>
<p><code><a href="../reference/setx.html">setx()</a></code> is typically independent of the model, and so we are not concerned with its workings here. For now, suffice to say that on <code><a href="../reference/setx.html">setx()</a></code>, there is a boolean field called <strong>bsetx</strong> that is assigned <code>TRUE</code>. <code><a href="../reference/sim.html">sim()</a></code>, on the other hand, is very much dependent on the model, and so this section describes <code><a href="../reference/sim.html">sim()</a></code> in detail.</p>
<p>There are four methods that are relevant to <code><a href="../reference/sim.html">sim()</a></code>, and they are executed in this order:</p>
<ol>
<li><p><code><a href="../reference/sim.html">sim()</a></code> defined in <em>Zelig</em></p></li>
<li><p><code>param()</code> defined in <em>Zelig-glm</em></p></li>
<li><p><code>simx()</code> defined in <em>Zelig</em></p></li>
<li><p><code>qi()</code> defined in <em>Zelig-binchoice</em></p></li>
</ol>
<p><code><a href="../reference/sim.html">sim()</a></code> calls <code>param()</code>, and later <code>simx()</code>. <code>param()</code> returns a matrix of draws from a multivariate normal via the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">return</span>(<span class="kw">mvrnorm</span>(.self<span class="op">$</span>num, <span class="kw">coef</span>(z.out), <span class="kw">vcov</span>(z.out)))</code></pre></div>
<p>Recall that the <strong>z.out</strong> field is equivalent to <strong>fit</strong> in <code>fit &lt;- glm(vote ~ age, data = turnout, family = binomial("logit"))</code>. <code>.self$num</code> specifies the number of samples taken from the multivariate normal distribution. Inside <code><a href="../reference/sim.html">sim()</a></code>, the field <strong>simparam</strong> is assigned the matrix returned by <code>param()</code>. Next, <code>simx()</code> is called, which assigns appropriate covariate values to <strong>mm</strong>, and then calls <code>qi()</code>, a method whose arguments are a matrix of simulated parameters (<strong>simparam</strong>) and a set of covariate values (<strong>mm</strong>).</p>
<p>That is important: <code>qi()</code> is a method whose arguments are a matrix of simulated parameters (<strong>simparam</strong>) and a set of covariate values (<strong>mm</strong>). <code>qi()</code> is the real workhorse method when we use <code><a href="../reference/sim.html">sim()</a></code>, and will likewise be the workhorse for any contributes models. Let’s walk through it line by line. The <code>qi()</code> method is written in <em>Zelig-binchoice</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">.self<span class="op">$</span>linkinv &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">call</span>(.self<span class="op">$</span>family, .self<span class="op">$</span>link))<span class="op">$</span>linkinv</code></pre></div>
<p>This is the first, and one of the more important, lines of code. Here is where we assign the <strong>linkinv</strong> field, which is the inverse of the logit link function. We know that <code>.self$family</code> is “binomial” and <code>.self$link</code> is “logit”, so perhaps this line is a bit easier to read like this: <code>.self$linkinv &lt;- eval(call(binomial, logit))$linkinv</code>. Recall that we have seen <code>call(.self$family, .self$link)</code> before, when we assigned it to the <strong>family</strong> field in our Zelig object. Recall that it evaluates to an object of class family, and, in our logit example, is equivalent to entering <code>binomial(logit)</code> into the R console.</p>
<p>Only now we don’t want a family object, but we want the inverse of the link function, which is contained <em>inside</em> the family object. Hence, from our family object, we reach in and grab <strong>linkinv</strong> (via <code>$linkinv</code>), and assign it to the <strong>linkinv</strong> field in our Zelig object. <strong>linkinv</strong> is a function, specifically, the inverse of the link function. For your model, this function may not exist, and may need to be written separately.</p>
<p>Just for clarification, enter the following in your R console, which is an R function that returns the inverse of the logit link:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">L &lt;-<span class="st"> </span><span class="cf">function</span>(m) {
    <span class="kw">return</span> (<span class="dv">1</span><span class="op">-</span>(<span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span><span class="op">+</span><span class="kw">exp</span>(m))))
}</code></pre></div>
<p>Next, enter <code>L(.5)</code>. Now enter <code>z5$linkinv(.5)</code>. The values returned will be identical. Try it with any value you like. This will work exactly the same way, with a different link function of course, regardless of which Zelig model is selected. Look at the next three lines in <code>qi()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">coeff &lt;-<span class="st"> </span>simparam
eta &lt;-<span class="st"> </span>simparam <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(mm)
eta &lt;-<span class="st"> </span><span class="kw">Filter</span>(<span class="cf">function</span> (y) <span class="op">!</span><span class="kw">is.na</span>(y), eta)</code></pre></div>
<p><strong>coeff</strong> is a copy of <strong>simparam</strong>, and <strong>eta</strong> is the matrix multiplication of <strong>simparam</strong> and <strong>mm</strong>, which produces a matrix of dimension <code>nrow(simparam) \times 1</code>. By default, <code>nrow(simparam)</code> is 1000. The final line drops any NAs in eta, and coerces the object from a matrix of one column to a numerical vector.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">theta &lt;-<span class="st"> </span><span class="kw">matrix</span>(.self<span class="op">$</span><span class="kw">linkinv</span>(eta), <span class="dt">nrow =</span> <span class="kw">nrow</span>(coeff))
ev &lt;-<span class="st"> </span><span class="kw">matrix</span>(.self<span class="op">$</span><span class="kw">linkinv</span>(eta), <span class="dt">ncol =</span> <span class="kw">ncol</span>(theta))
pv &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">nrow =</span> <span class="kw">nrow</span>(ev), <span class="dt">ncol =</span> <span class="kw">ncol</span>(ev)).</code></pre></div>
<p>Here, we construct a 1000x1 matrix and assign it to <strong>theta</strong>. <code>.self$linkinv(eta)</code> is simply the inverse link applied to each value in the eta vector, and this fills in the values of the <strong>theta</strong> matrix. The number of rows in the matrix theta are the number of simulations, or the number of rows in the matrix of simulated parameters. <strong>ev</strong> and <strong>pv</strong> have a number of rows equal to the number of observations in eta after NAs are dropped, and a number of columns equal to 1.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(ev))
    pv[, j] &lt;-<span class="st"> </span><span class="kw">rbinom</span>(<span class="kw">length</span>(ev[, j]), <span class="dv">1</span>, <span class="dt">prob =</span> ev[, j])
<span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">ev =</span> ev, <span class="dt">pv =</span> pv))</code></pre></div>
<p>Next, we iterate over the columns in the <strong>ev</strong> matrix, and assign predicted values one column at a time. For the default number of simulations (1000) and the logit, this is 1000 draws from a binomial distribution, each with a trial size of 1 and a probability of drawing 1 equal to the value in the corresponding cell in the <span class="math inline">\(j^{th}\)</span> column of <strong>ev</strong>. Lastly, we return a list with two objects, each a matrix, holding our expected values and predicted values.</p>
<p>Now we have our function that simulates the quantities of interest. These quantities of interest, and the model estimates, are the primary components used in Zelig’s various plot, accessible with <code>z5$graph()</code>.</p>
</div>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p>See the Zelig documentation for more details about <code>by</code>.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#getting-started">Getting Started</a></li>
      <li><a href="#reference-classes-and-inheritance">Reference Classes and Inheritance</a></li>
      <li><a href="#zelig-methods">Zelig Methods</a></li>
      <li><a href="#new"><code>new()</code></a></li>
      <li><a href="#zelig"><code><a href="--/reference/zelig-html">zelig()</a></code></a></li>
      <li><a href="#sim"><code><a href="--/reference/sim-html">sim()</a></code></a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, Olivia Lau.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
